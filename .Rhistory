c = 1
library(readxl)
X2012_dati <- read_excel("C:/Users/fabio/Downloads/Anni/Anni/2012_dati.csv")
View(X2012_dati)
rating <- read.delim("~/R/IBM/rating.tsv")
View(rating)
x11()
plot(rating$averageRating[1:100])
plot(rating$numVotes[1:100], rating$averageRating[1:100])
plot(log(rating$numVotes[1:100]), rating$averageRating[1:100])
rating$averageRating[1]
rating$averageRating[1:10]
1:10
mask = rating$averageRating == 5
mask[1:20]
rating$averageRating[mask]
rating$numVotes[mask]
rating$averageRating[c(1,4,2)]
rating$averageRating[1:10:2]
rating[1:100]
rating[1:100,:]
install(dplyr)
install.packages("dplyr")
rating[1:10]
rating[1:10,]
rating[1:10,2]
rating[1:10,c(2,3)]
c(1,4,5,6)
rating[1:10,c(2,3)]
df = rating[1:1000, c(2,3)]
View(df)
plot(df)
hist(rating$averageRating)
hist(rating$numVotes)
rating$logNumVotes = log(rating$numVotes)
hist(rating$logNumVotes)
plot(rating)
boxplot(rating$averageRating)
getwd()
a=list(c(1,2))
a[1]
a[[1]
]
a[[1]]
a[[2]]
a[[0]]
a
a=list(1,2)
a
a[1]
a[2]
a[[2]]
a[[1]]
a[1]
source("utilityFunctions.R")
setwd("~/GitHub/GraphicalMdels-BayesStat")
getwd()
setwd("~/GitHub/GraphicalMdels-BayesStat")
setwd("C:/Users/fabio/OneDrive/Documenti/GitHub/GraphicalMdels-BayesStat")
setwd("C:/Users/fabio/OneDrive/Documenti/GitHub/GraphicalModels-BayesStat")
setwd("~/GitHub/GraphicalModels-BayesStat")
source("utilityFunctions.R")
GenerateGaussianDataFromGraph(adjacencyMatrix=matrix(c(c(0,0,1,0,0,1),c(0,0,0,1,1,0),c(1,0,0,0,1,1),c(0,1,0,0,1,0),c(0,1,1,1,0,0),c(1,0,1,0,0,0)), nrow=6, ncol=6), n.obs=1000, n.variables=6)
GenerateGaussianDataFromGraph = function(adjacencyMatrix=NULL, n.obs, n.variables, p=NULL, covaraince=NULL){
#This function generate a dataset of n.obs number of observation issued from a multivariate gaussian with dimension n.variables
#The data are being generated accoring to the graph given by adjacencyMatrix or by p which is the vector of probability that an edge will be in the graph
#If the covariance Sigma is null, the function will sample one from the Hyper Inverse Wishart distribution.
#The function returns a list with the adjacency matrix, the data and the covariance which generated the data.
if(is.null(adjacencyMatrix)){
while(TRUE){
graph = erdos.renyi.game(n.variables,p,type="gnp",directed = FALSE)
adjacencyMatrix = as_adjacency_matrix(graph, sparse = 0)
if(isDecomposable(adjacencyMatrix)){
break
}
}
}
if(!isDecomposable(adjacencyMatrix)){
stop("Graph should be decomposable.")
}
inv.covariance = rgwish(1, adj = adjacencyMatrix, D = 10 * diag(1,n.variables))
covariance = solve(inv.covariance)
mu = c(rep(0, n.variables))
data = dataCopy = data.frame(rmvnorm(n.obs, mu, covariance))
return (list(adjacencyMatrix, data, covariance))
}
(A,data,cov) = GenerateGaussianDataFromGraph(adjacencyMatrix=matrix(c(c(0,0,1,0,0,1),c(0,0,0,1,1,0),c(1,0,0,0,1,1),c(0,1,0,0,1,0),c(0,1,1,1,0,0),c(1,0,1,0,0,0)), nrow=6, ncol=6), n.obs=1000, n.variables=6)
res = GenerateGaussianDataFromGraph(adjacencyMatrix=matrix(c(c(0,0,1,0,0,1),c(0,0,0,1,1,0),c(1,0,0,0,1,1),c(0,1,0,0,1,0),c(0,1,1,1,0,0),c(1,0,1,0,0,0)), nrow=6, ncol=6), n.obs=1000, n.variables=6)
source("utilityFunctions.R")
install.packages("pcalg")
source("utilityFunctions.R")
rm(list = ls())
setwd("~/GitHub/GraphicalMdels-BayesStat")
setwd("~/GitHub/GraphicalModels-BayesStat")
source("categorical.R")
pi
source("utilityFunctions.R")
install.packages("pcalg", repos=c("http://rstudio.org/_packages", "http://cran.rstudio.com"))
source("utilityFunctions.R")
install.packages("pcalg", dependencies = TRUE)
source("utilityFunctions.R")
setwd("~/GitHub/GraphicalModels-BayesStat")
source("Gaussian.R")
source("Gaussian.R")
install.packages("pcalg", type="binary")
source("Gaussian.R")
source("http://bioconductor.org/biocLite.R")
biocLite("RBGL")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("graph", "RBGL", "Rgraphviz"))
source("Gaussian.R")
source("Gaussian.R")
source("Gaussian.R")
res = generateGaussianDataFromGraph(adjacencyMatrix=matrix(c(c(0,0,1,0,0,1),c(0,0,0,1,1,0),c(1,0,0,0,1,1),c(0,1,0,0,1,0),c(0,1,1,1,0,0),c(1,0,1,0,0,0)), nrow=6, ncol=6), n.obs=1000, n.variables=6)
res[[1]]
res[1]
res[[2]]
plot(res[[2]][:,1], res[[2]][:,2])
plot(res[[2]][,1], res[[2]][,2])
plot(res[[2]][,2], res[[2]][,3])
plot(res[[2]][,3], res[[2]][,4])
plot(res[[2]][,3], res[[2]][,6])
trueGraphs = list()
encodedList = c()
for(i in 1:20){
while(TRUE){
graph = erdos.renyi.game(6,0.3,type="gnp",directed = FALSE)
newGraph = as_adjacency_matrix(graph, sparse = 0)
encoded = encodeGraph(newGraph)
if(isDecomposable(newGraph) & !encoded %in% encodedList){
trueGraphs[[i]] = newGraph
encodedList = c(encodedList,encoded)
break
}
}
}
mpgs = list()
maps = list()
mpg_distances = c()
map_distances = c()
count = 1
for(trueGraph in trueGraphs){
data = generateGaussianDataFromGraph(adjacencyMatrix = trueGraph, n.obs = 10000, n.variables = 6)
initialCandidate = matrix(0,6,6)
chain = MetropolisHastingsGaussian(data[[2]], initialCandidate, 1000, 500, 1, prior = "Binomial", p=0.3)
# Median Probability Graph
mpg = medianProbabilityGraph(chain)
mpgs[[count]] = mpg
mpg_distances = c(mpg_distances,computeSHD(trueGraph,mpg))
# Maximum a Posteriori Graph
map = maximumPosterioriGraph(chain)
maps[[count]] = map
map_distances = c(map_distances,computeSHD(trueGraph,map))
# Increase count
count = count + 1
}
install.packages('Rcpp')
library(Rcpp)
install.packages("Rcpp")
for(trueGraph in trueGraphs){
data = generateGaussianDataFromGraph(adjacencyMatrix = trueGraph, n.obs = 10000, n.variables = 6)
initialCandidate = matrix(0,6,6)
chain = MetropolisHastingsGaussian(data[[2]], initialCandidate, 1000, 500, 1, prior = "Binomial", p=0.3)
# Median Probability Graph
mpg = medianProbabilityGraph(chain)
mpgs[[count]] = mpg
mpg_distances = c(mpg_distances,computeSHD(trueGraph,mpg))
# Maximum a Posteriori Graph
map = maximumPosterioriGraph(chain)
maps[[count]] = map
map_distances = c(map_distances,computeSHD(trueGraph,map))
# Increase count
count = count + 1
}
source("Gaussian.R")
